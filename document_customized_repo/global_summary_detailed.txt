Below is a high-level explanation of the top-level “priority_encoder” module. The explanation is written so that an experienced hardware designer can implement the same functionality in one monolithic module using the identical interface. It assumes knowledge of Verilog/SystemVerilog constructs but highlights all essential functionality:

-------------------------------------------------------------------------------
1. Module Interface and Parameters
-------------------------------------------------------------------------------
• Module name: priority_encoder  
• Parameters:  
  – WIDTH (integer ≥ 1; defaults to 4): The width of the unencoded input.  
  – LSB_HIGH_PRIORITY (integer 0 or 1; defaults to 0): Determines whether the lowest-set bit (if set to 1) or the highest-set bit (if set to 0) is chosen when multiple bits of the input are set.  

• Ports:  
  1) input_unencoded  : input wire [WIDTH-1:0]  
     – Carries the signals to be encoded.  
     – Bit 0 is the least significant bit, bit (WIDTH-1) is the most significant bit.  
     – No clocking—this module is purely combinational.

  2) output_valid     : output wire  
     – Single-bit output.  
     – High (1) if at least one bit of “input_unencoded” is set; Low (0) if no bits are set.

  3) output_encoded   : output wire [$clog2(WIDTH)-1:0]  
     – Encodes the position of the bit in the input_unencoded that has “priority.”  
     – The exact interpretation (which bit gets priority if more than one is set) is determined by LSB_HIGH_PRIORITY.  
       • If LSB_HIGH_PRIORITY=0, the highest-position set bit is prioritized.  
       • If LSB_HIGH_PRIORITY=1, the lowest-position set bit is prioritized.  
     – The width of this output is log2(WIDTH).

  4) output_unencoded : output wire [WIDTH-1:0]  
     – A one-hot representation of which input bit was selected as the “priority” bit.  
     – Only one bit of this output will be high if output_valid=1.  
     – If no input bits are set (output_valid=0), the one-hot output is typically all 0s (by convention).

No registers are used in the top-level interface—everything is combinational. The module’s internals rely on hierarchical logic (through generate constructs) to produce these outputs.

-------------------------------------------------------------------------------
2. Overview of the Priority Encoder Function
-------------------------------------------------------------------------------
At a high level, this module detects which bit in the “input_unencoded” signal should be selected when multiple bits are set. Two common conventions are supported:
• LSB-high priority: choose the smallest bit index that is set.  
• MSB-high priority: choose the largest bit index that is set.

Once identified, the module outputs:
1. A validity bit (output_valid) to indicate if anything was set.  
2. A binary-encoded index (output_encoded) giving the number of that bit.  
3. A one-hot representation (output_unencoded) of that chosen bit.

-------------------------------------------------------------------------------
3. Internal Hierarchical Structure
-------------------------------------------------------------------------------
Even though the final design can be built in one flat structure, the provided code implements a hierarchical priority encoder in stages. These stages can be conceptually visualized (though you may implement them in a single loop or combinational block). The relevant internal signals and steps are:

(1) Compute LEVELS = $clog2(WIDTH).  
    – This tells how many stages are needed if the logic is grouped in pairs, then pairs of pairs, etc.  

(2) Define W = 2**LEVELS.  
    – W is the smallest power of two that is ≥ WIDTH.  
    – The input is padded with 0s up to W bits to simplify the pairing.  

(3) stage_valid[l] and stage_enc[l]:  
    – For each pipeline “level” l, stage_valid[l] holds which pair/group from the previous level contained at least one set bit.  
    – stage_enc[l] holds the partial encoding of which bit was set.  

(4) First Stage (Pairwise Checks):  
    – The code splits the padded input into 2-bit slices.  
    – For each 2-bit slice, it checks if that slice