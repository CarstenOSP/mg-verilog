{"priority_encoder.v": {"global_summary_high_level": "This module identifies which bit in the input bus is set first according to a selectable priority scheme (either least-significant-bit-first or most-significant-bit-first). It automatically expands the input to the nearest power of two, then uses multiple hierarchical stages to detect a valid bit and determine its index. Finally, it exposes three key outputs: a valid signal indicating whether any bit was set, the encoded index of that bit, and a one-hot output that marks exactly which bit in the original input was selected.", "global_summary_detailed": "Below is a high-level explanation of the top-level \u201cpriority_encoder\u201d module. The explanation is written so that an experienced hardware designer can implement the same functionality in one monolithic module using the identical interface. It assumes knowledge of Verilog/SystemVerilog constructs but highlights all essential functionality:\n\n-------------------------------------------------------------------------------\n1. Module Interface and Parameters\n-------------------------------------------------------------------------------\n\u2022 Module name: priority_encoder  \n\u2022 Parameters:  \n  \u2013 WIDTH (integer \u2265 1; defaults to 4): The width of the unencoded input.  \n  \u2013 LSB_HIGH_PRIORITY (integer 0 or 1; defaults to 0): Determines whether the lowest-set bit (if set to 1) or the highest-set bit (if set to 0) is chosen when multiple bits of the input are set.  \n\n\u2022 Ports:  \n  1) input_unencoded  : input wire [WIDTH-1:0]  \n     \u2013 Carries the signals to be encoded.  \n     \u2013 Bit 0 is the least significant bit, bit (WIDTH-1) is the most significant bit.  \n     \u2013 No clocking\u2014this module is purely combinational.\n\n  2) output_valid     : output wire  \n     \u2013 Single-bit output.  \n     \u2013 High (1) if at least one bit of \u201cinput_unencoded\u201d is set; Low (0) if no bits are set.\n\n  3) output_encoded   : output wire [$clog2(WIDTH)-1:0]  \n     \u2013 Encodes the position of the bit in the input_unencoded that has \u201cpriority.\u201d  \n     \u2013 The exact interpretation (which bit gets priority if more than one is set) is determined by LSB_HIGH_PRIORITY.  \n       \u2022 If LSB_HIGH_PRIORITY=0, the highest-position set bit is prioritized.  \n       \u2022 If LSB_HIGH_PRIORITY=1, the lowest-position set bit is prioritized.  \n     \u2013 The width of this output is log2(WIDTH).\n\n  4) output_unencoded : output wire [WIDTH-1:0]  \n     \u2013 A one-hot representation of which input bit was selected as the \u201cpriority\u201d bit.  \n     \u2013 Only one bit of this output will be high if output_valid=1.  \n     \u2013 If no input bits are set (output_valid=0), the one-hot output is typically all 0s (by convention).\n\nNo registers are used in the top-level interface\u2014everything is combinational. The module\u2019s internals rely on hierarchical logic (through generate constructs) to produce these outputs.\n\n-------------------------------------------------------------------------------\n2. Overview of the Priority Encoder Function\n-------------------------------------------------------------------------------\nAt a high level, this module detects which bit in the \u201cinput_unencoded\u201d signal should be selected when multiple bits are set. Two common conventions are supported:\n\u2022 LSB-high priority: choose the smallest bit index that is set.  \n\u2022 MSB-high priority: choose the largest bit index that is set.\n\nOnce identified, the module outputs:\n1. A validity bit (output_valid) to indicate if anything was set.  \n2. A binary-encoded index (output_encoded) giving the number of that bit.  \n3. A one-hot representation (output_unencoded) of that chosen bit.\n\n-------------------------------------------------------------------------------\n3. Internal Hierarchical Structure\n-------------------------------------------------------------------------------\nEven though the final design can be built in one flat structure, the provided code implements a hierarchical priority encoder in stages. These stages can be conceptually visualized (though you may implement them in a single loop or combinational block). The relevant internal signals and steps are:\n\n(1) Compute LEVELS = $clog2(WIDTH).  \n    \u2013 This tells how many stages are needed if the logic is grouped in pairs, then pairs of pairs, etc.  \n\n(2) Define W = 2**LEVELS.  \n    \u2013 W is the smallest power of two that is \u2265 WIDTH.  \n    \u2013 The input is padded with 0s up to W bits to simplify the pairing.  \n\n(3) stage_valid[l] and stage_enc[l]:  \n    \u2013 For each pipeline \u201clevel\u201d l, stage_valid[l] holds which pair/group from the previous level contained at least one set bit.  \n    \u2013 stage_enc[l] holds the partial encoding of which bit was set.  \n\n(4) First Stage (Pairwise Checks):  \n    \u2013 The code splits the padded input into 2-bit slices.  \n    \u2013 For each 2-bit slice, it checks if that slice", "global_summary_from_line_comments": "{\"usage\": \"This parameterizable priority encoder can be instantiated in digital designs requiring an index of the first asserted bit. It offers a configurable width and supports both LSB-high and MSB-high priority selection based on the LSB_HIGH_PRIORITY parameter.\", \"summary\": \"The module performs a hierarchical priority encoding of the input bits, returning a valid flag, a log2(WIDTH)-bit encoded index, and a one-hot output. It splits the input into pairs, determines which pair has priority, and iteratively refines until one final index is chosen. Depending on the LSB_HIGH_PRIORITY setting, the module either prioritizes the lower or the higher bit in each pair, ensuring flexibility in how the highest-priority set bit is identified.\"}", "module_header": "module priority_encoder # (parameter WIDTH = 4,parameter LSB_HIGH_PRIORITY = 0) (input wire [WIDTH-1:0] input_unencoded,output wire output_valid,output wire [$clog2(WIDTH)-1:0] output_encoded,output wire [WIDTH-1:0] output_unencoded);"}}