{"priority_encoder.v": {"path": "output_dir//documented_code/part0/priority_encoder/priority_encoder.v", "name": "priority_encoder.v", "genre": ", documented_code, part0, priority_encoder", "global_summary_from_line_comments_path": "output_dir//documented_code/part0/priority_encoder/priority_encoder.txt", "global_summary_from_line_comments": "{\"usage\": \"Instantiate this parameterizable priority encoder when you need to determine a valid index of the highest (or lowest) priority set bit in an input vector. It simultaneously provides a valid flag, a binary-encoded result, and a one-hot representation corresponding to the identified bit. Adjust the WIDTH parameter to match the input size, and use LSB_HIGH_PRIORITY to control whether the least significant bit or the most significant bit has priority.\", \"summary\": \"This module extends a simple priority encoder into multiple pipeline levels by padding the input to the nearest power of two and iteratively reducing valid signals while creating partial encodings. The final outputs indicate (1) whether any input bit is set (output_valid), (2) the binary encoding of the set bit (output_encoded), and (3) a one-hot representation of that position (output_unencoded). The design supports both LSB- and MSB-first priority selection.\"}", "block_summary": ["This block first figures out how many stages the priority encoder needs based on the input width. It then computes the next power-of-two size to cover all input bits and pads the original input to match that size. Arrays are declared to track, at each stage, which groups of bits contain at least one \u201c1\u201d (the valid signals) and how those valid signals map to partial one-hot encodings. Finally, it initializes the first stage by dividing the padded input", "", "This block finalizes the multi-level selection process and produces the output signals. At each stage, it examines a pair of previously computed valid bits to decide which half contains a set bit and then selects the corresponding portion of the partial encoding. It also prefixes an additional bit to signify which half was chosen, thereby incrementally extending the partial encoded result. Finally, once all levels have been processed, the module outputs three signals: a single valid bit indicating that at least one input was set, a binary-encoded index pinpointing the highest-priority set bit, and a one-hot representation of that index.", "This concludes the Verilog module definition, marking the end of all logic and parameter declarations for the priority encoder."], "detailed_steps": null, "module_header": "module priority_encoder # (parameter WIDTH = 4,parameter LSB_HIGH_PRIORITY = 0) (input wire [WIDTH-1:0] input_unencoded,output wire output_valid,output wire [$clog2(WIDTH)-1:0] output_encoded,output wire [WIDTH-1:0] output_unencoded);", "global_summary_high_level": "This module identifies the highest-priority set bit in an input vector (with optional LSB-first priority), then signals if any bit is set, provides a binary index of the chosen bit, and offers a one-hot representation of that position. Internally, it processes the input through multiple hierarchy levels (if needed), consolidates partial decisions at each stage, and outputs valid, encoded, and one-hot signals to indicate which bit is the highest priority set bit.", "global_summary_detailed": "Overview  \n-------------------------------------------------------------------------------\nThis top-level module implements a parameterized priority encoder. It accepts a vector of one or more bits and outputs three signals:\n\n1. output_valid (1 bit): Indicates that at least one bit in the input vector is set to 1.\n2. output_encoded (\u2308log2(WIDTH)\u2309 bits): Provides a binary index corresponding to the highest-priority set bit of the input vector.\n3. output_unencoded (WIDTH bits): Provides a one-hot representation of that same index.\n\nThe module\u2019s parameters are:  \n\u2022 WIDTH: The width of the input vector (integer \u2265 1).  \n\u2022 LSB_HIGH_PRIORITY: A boolean parameter (0 or 1) that determines whether the least significant bit has higher priority (when set to 1) or the most significant bit in each pair has higher priority (when set to 0).\n\nI/O Specifications  \n-------------------------------------------------------------------------------\n\u2022 input_unencoded [WIDTH-1:0] (input):  \n  \u2013 Each bit is valid logic \u201c0\u201d or \u201c1\u201d.  \n  \u2013 This is the vector on which priority encoding is performed.\n\n\u2022 output_valid (output):  \n  \u2013 1 bit wide.  \n  \u2013 Outputs \u20181\u2019 if at least one bit of input_unencoded is \u20181\u2019, otherwise outputs \u20180\u2019.\n\n\u2022 output_encoded [\u2308log2(WIDTH)\u2309-1 : 0] (output):  \n  \u2013 Encodes the index of the highest priority set bit in the input.  \n  \u2013 Range is from 0 to (WIDTH-1).  \n  \u2013 If no bits are set (i.e., if output_valid=0), the encoder still produces a binary value, but that value is only meaningful if output_valid=1.\n\n\u2022 output_unencoded [WIDTH-1:0] (output):  \n  \u2013 One-hot representation of the highest-priority set bit.  \n  \u2013 Exactly one bit will be \u20181\u2019 in this output if output_valid=1 (the bit that corresponds to output_encoded).  \n  \u2013 If output_valid=0, the one-hot output will typically be all zeros.\n\nHigh-Level Functionality  \n-------------------------------------------------------------------------------\n1. Determination of Internal Size (Power-of-Two Padding):  \n   a) The module calculates LEVELS = \u2308log2(WIDTH)\u2309.  \n   b) It also determines W = 2**LEVELS, the smallest power of two >= WIDTH.  \n   c) If WIDTH is not itself a power of two, the input_unencoded is padded with zeros up to W bits (input_padded).  \n      - For example, if WIDTH=5, then LEVELS=3 (because 2\u00b3=8 \u2265 5), and W=8. The 5 input bits get concatenated to 3 zeros for uniform processing.\n\n2. Multi-Level Priority Detection (stage_valid) and Encoding (stage_enc):  \n   a) The design logically groups bits into pairs at the first level and determines whether each 2-bit slice contains at least one \u20181\u2019.  \n      - stage_valid[0][n] = OR of each 2-bit pair.  \n      - stage_enc[0][n] = choice of which bit in those two is highest priority.  \n        \u00b7 If LSB_HIGH_PRIORITY = 1, the least significant bit in that 2-bit pair has higher priority, so the encoder uses \u201c~LSB\u201d as the partial code.  \n        \u00b7 If LSB_HIGH_PRIORITY = 0, the most significant bit in that 2-bit pair has higher priority, so the encoder uses \u201cMSB\u201d as the partial code.\n\n     Example for one 2-bit pair in the first stage, with signals called bit1:bit0:  \n       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       \u2502     Inputs (bit1:bit0)\u2502   stage_valid[0][n]   \u2502  stage_enc[0][n]  \u2502\n       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n       \u2502       00              \u2502        0              \u2502   (depends on LSB_HIGH_PRIORITY, but no set bits \u2192 not used)  \n       \u2502       10              \u2502        1              \u2502   = bit1 if LSB_HIGH_PRIORITY=0, = !bit0 if LSB_HIGH_PRIORITY=1  \n       \u2502       01              \u2502        1              \u2502   same logic, reversed roles  \n       \u2502       ", "related_lit_docs_per_code_large_in_vecstore": false, "related_lit_docs_per_code_small_in_vecstore": false, "related_lit_docs_global_in_vecstore": false, "related_lit_docs_global_titles_in_vecstore": false, "csv_code": "output_dir//output_dir_for_code_metadata/part0/assets/verilog/code_and_comment_src/csv_src/csv_code_src/priority_encoder.csv", "csv_comment": "output_dir//output_dir_for_code_metadata/part0/assets/verilog/code_and_comment_src/csv_src/csv_new_comment_src/priority_encoder.csv", "splitted_idx": [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [10, 11, 12, 13, 14, 15, 16, 17, 18, 19], [20, 21, 22, 23, 24, 25, 26, 27, 28, 29], [30]]}}