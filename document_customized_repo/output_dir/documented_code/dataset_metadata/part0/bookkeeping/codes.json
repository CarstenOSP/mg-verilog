{"priority_encoder.v": {"path": "output_dir/documented_code/part0/priority_encoder/priority_encoder.v", "name": "priority_encoder.v", "genre": "documented_code, part0, priority_encoder", "global_summary_from_line_comments_path": "output_dir/documented_code/part0/priority_encoder/priority_encoder.txt", "global_summary_from_line_comments": "{\"usage\": \"Instantiate this module where a priority encoder is needed to detect the first asserted bit in a multibit signal, setting LSB_HIGH_PRIORITY=1 to prioritize lower indices or 0 for higher indices. Outputs include a valid indicator, an integer-encoded index, and a corresponding one-hot representation.\", \"summary\": \"This parameterizable priority encoder pads the input to the nearest power of two and processes it in multiple stages, combining pairs of bits at each level to produce an encoded index of the highest-priority active bit. The final stage provides a one-hot output, alongside a valid signal and the integer-encoded index. The LSB_HIGH_PRIORITY parameter toggles the direction of priority.\"}", "block_summary": ["This section calculates how many hierarchical stages are needed for encoding, always ensuring at least one. It then finds and stores the power-of-two size that exceeds or equals the original width, and pads the input bits with zeros to match that size. Arrays are declared to hold \u201cvalid\u201d signals and partial encoding results for each stage. A generate loop then inspects each pair of padded input bits to determine whether at least one bit in the pair is active, marking those pairs as valid for further processing in the subsequent encoding levels.", "This block first determines how each pair of bits contributes to the initial encoded output based on whether the least significant bit has priority. When least significant bits take priority, the encoded bit is derived from the least significant side of the pair; otherwise, the more significant side is used. After establishing this initial encoding, a multi-level loop progressively combines pairs of signals from the prior stage into single valid outputs for the next stage. At each compression level, it merges the \u201cvalid\u201d signals and then applies the selected priority scheme to prepare intermediate encoding results, continuing until all hierarchy levels are processed.", "", "This final line concludes the module definition. It does not introduce any additional logic or outputs; instead, it simply signifies the end of the priority encoder module, ensuring that all preceding declarations and generated structures are fully enclosed within the design."], "detailed_steps": null, "module_header": "module priority_encoder # (parameter WIDTH = 4,parameter LSB_HIGH_PRIORITY = 0) (input wire [WIDTH-1:0] input_unencoded,output wire output_valid,output wire [$clog2(WIDTH)-1:0] output_encoded,output wire [WIDTH-1:0] output_unencoded);", "global_summary_high_level": "This priority encoder checks which input bit is active and provides three outputs:  \n\u2022 A \u201cvalid\u201d indicator if any bit is set.  \n\u2022 A binary-encoded position of the active bit, with optional least-significant-bit priority.  \n\u2022 A one-hot signal that activates exactly the position of the detected bit.  \n\nInternally, the design scales the input width to a power of two (if needed) and then progressively compresses pairs of bits in a hierarchical fashion until a single encoded result is formed. This final result is then presented through the valid output, the encoded index, and the one-hot output.", "global_summary_detailed": "Below is a high-level explanation of the \u201cpriority_encoder\u201d module\u2019s functionality, focusing on how the design locates and encodes the \u201chighest-priority\u201d set bit (bit equal to 1) among its inputs. It is intended to serve as the only specification necessary for an experienced hardware designer to implement the same functionality in a single top-level module with the same interface.\n\n-------------------------------------------------------------------------------\n1) MODULE INTERFACE AND PARAMETERS\n-------------------------------------------------------------------------------\n\u2022 Module Name: priority_encoder\n\u2022 Parameter WIDTH (integer, \u2265 1): Specifies the width of the input vector \u201cinput_unencoded.\u201d This is the number of bits the encoder must examine.\n\u2022 Parameter LSB_HIGH_PRIORITY (integer, 0 or 1): \n  \u2013 0 indicates the most significant \u20181\u2019 bit has higher priority (MSB priority).\n  \u2013 1 indicates the least significant \u20181\u2019 bit has higher priority (LSB priority).\n\nPorts (all combinational I/O):\n\u2022 input_unencoded [WIDTH-1:0] : (Input) A WIDTH-bit vector whose bits may be 0 or 1 in any pattern. The encoder will find which bit has priority if any are active.\n\u2022 output_valid (1 bit)        : (Output) Indicates whether at least one bit of \u201cinput_unencoded\u201d is set to 1. \n  \u2013 1 = \u201cThere is a set bit somewhere.\u201d  \n  \u2013 0 = \u201cNo bits are set; the input is all zeros.\u201d\n\u2022 output_encoded [$clog2(WIDTH)-1:0] : (Output) The binary index identifying the position of the highest-priority set bit. If output_valid=0, this value is undefined in typical implementations but will still drive some binary value.\n\u2022 output_unencoded [WIDTH-1:0]       : (Output) A one-hot representation of the location of the highest-priority set bit. Exactly one output bit is 1 if valid, and the rest are 0.\n\nConstraints/Behavior:\n\u2022 Each output signal is purely combinationally determined by \u201cinput_unencoded\u201d and the priority setting (LSB_HIGH_PRIORITY). There is no clock or sequential pipeline in this design.\n\u2022 The design automatically computes the correct number of bits in \u201coutput_encoded\u201d by using $clog2(WIDTH).\n\u2022 The design supports any WIDTH \u2265 1. Internally, if WIDTH is not a power of two, the module pads the input to the nearest power-of-two size to ease the hierarchy of combining pairs.\n\n-------------------------------------------------------------------------------\n2) OVERALL ENCODER FUNCTION\n-------------------------------------------------------------------------------\nThe primary goal is to select which input bit is considered \u201cactive\u201d according to the priority scheme, and to provide three forms of output:\n1. A valid indicator: output_valid\n2. A binary-encoded index: output_encoded\n3. A one-hot vector: output_unencoded\n\nAt a high level, the encoder works in multiple stages:\n\u2022 Stage 0 (the \u201cfirst stage\u201d): \n  \u2013 Breaks the input into 2-bit chunks (pairs). \n  \u2013 For each pair, it decides two things: \n    (a) Is there at least one \u20181\u2019 in that pair? (This becomes a \u201cvalid\u201d signal for that pair.)  \n    (b) If valid, which bit\u2019s index (0 vs. 1 in the pair) gets chosen for partial encoding? This depends on LSB_HIGH_PRIORITY.  \n\u2022 Stage 1, 2, \u2026, up to \u201cLEVELS-1\u201d: \n  \u2013 Successively merge pairs of partial results from the previous stage. \n  \u2013 Each merge step again decides whether the combined pair is valid and which half of the pair to pick if one or both are valid.  \n\u2022 Final Outputs: \n  \u2013 output_valid is set high if any valid signals ultimately survive in the top-most compression level. \n  \u2013 output_encoded is the final aggregated \u201cpartial encoding\u201d from the highest stage. \n  \u2013 output_unencoded is formed by one-hot decoding that final encoded value.\n\nBecause the design methodically halves the input size at each level (merging 2 bits, then 4, then 8, etc.), it takes approximately log\u2082(WIDTH) levels (or simply 1 level if WIDTH \u2264 2) to process the entire input vector into a single final result.\n\n-------------------------------------------------------------------------------\n3) DETAILED FUNCTIONAL STEPS\n-------------------------------------------------------------------------------\n\nA. POWER-OF-TWO ALIGNMENT AND PADDING\n-------------------------------------\n1. The module first calculates:\n     LEVELS = (WIDTH > 2)? $clog2(WIDTH) : 1\n   so there is always at least one stage.  \n2. It then defines W = 2**LEVELS, which is the nearest power-of-two size \u2265 WIDTH.  \n3. The vector \u201cinput_padded\u201d is formed by zero-extending \u201cinput_unencoded\u201d to width W:\n     input_padded = { (W-WIDTH){1'b0} , input_unencoded }\n   This simplifies pairwise merging because each stage can treat W as a power-of-two length.\n\nB. FIRST STAGE OF ENCODING (Stage 0)\n------------------------------------\n\u2022 The design divides \u201cinput_padded\u201d into pairs of bits: (2 bits per pair).  \n\u2022 For pair n, the lines are:\n  \u2013 stage_valid[0][n] = OR of the two bits in the pair. This is 1 if either bit is 1.  \n  \u2013 stage_enc[0][n]   = the partial encoded bit for that pair, determined differently depending on LSB_HIGH_PRIORITY:  \n    \u00b0 If LSB_HIGH_PRIORITY=1, we choose the LSB side if", "related_lit_docs_per_code_large_in_vecstore": false, "related_lit_docs_per_code_small_in_vecstore": false, "related_lit_docs_global_in_vecstore": false, "related_lit_docs_global_titles_in_vecstore": false, "csv_code": "output_dir/output_dir_for_code_metadata/part0/assets/verilog/code_and_comment_src/csv_src/csv_code_src/priority_encoder.csv", "csv_comment": "output_dir/output_dir_for_code_metadata/part0/assets/verilog/code_and_comment_src/csv_src/csv_new_comment_src/priority_encoder.csv", "splitted_idx": [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [10, 11, 12, 13, 14, 15, 16, 17, 18, 19], [20, 21, 22, 23, 24, 25, 26, 27, 28, 29], [30]]}}